"use server";

import { z } from "zod";
import type { Submission, SubmissionDocument } from '@/lib/types'; // Import SubmissionDocument from types
import { promises as fs } from 'fs';
import path from 'path';
import dbConnect from '@/lib/mongodb'; // Import database connection
import SubmissionModel from '@/models/Submission'; // Import Submission Mongoose model
import mongoose from 'mongoose'; // Import mongoose types if needed

// --- Zod Schema for Input Validation ---
const submissionSchema = z.object({
  name: z.string().optional(),
  contactInfo: z.string().optional(),
  category: z.string(),
  description: z.string().min(10).max(1000),
  // File is handled separately via FormData
});

// --- Helper Functions ---

// Simulates saving a file and returning its URL (replace with actual storage logic)
async function saveFile(file: File): Promise<string | null> {
    if (!file) return null;

    try {
        const uploadsDir = path.join(process.cwd(), 'public/uploads');
        // Ensure the uploads directory exists
        await fs.mkdir(uploadsDir, { recursive: true });

        const fileBuffer = Buffer.from(await file.arrayBuffer());
        const uniqueFilename = `${Date.now()}-${file.name.replace(/\s+/g, '_')}`;
        const filePath = path.join(uploadsDir, uniqueFilename);

        await fs.writeFile(filePath, fileBuffer);

        // Return the public URL path
        return `/uploads/${uniqueFilename}`;
    } catch (error) {
        console.error("Error saving file:", error);
        return null; // Indicate failure
    }
}

// --- Server Actions ---

/**
 * Creates a new submission.
 * Handles file upload if present.
 * Saves data to MongoDB.
 */
export async function createSubmission(formData: FormData): Promise<{ success: boolean; referenceId?: string; error?: string }> {
  await dbConnect(); // Connect to the database

  try {
    const rawData = {
        name: formData.get('name') as string | undefined,
        contactInfo: formData.get('contactInfo') as string | undefined,
        category: formData.get('category') as string,
        description: formData.get('description') as string,
    };
    const file = formData.get('file') as File | null;

    // Validate text fields
    const validation = submissionSchema.safeParse(rawData);
    if (!validation.success) {
      return { success: false, error: validation.error.errors.map(e => e.message).join(', ') };
    }

    const validatedData = validation.data;

    // Handle file upload
    let fileUrl: string | null = null;
    if (file) {
         if (file.size > 5 * 1024 * 1024) { // 5MB limit
            return { success: false, error: "Ukuran file melebihi batas 5MB." };
         }
        const allowedTypes = ['image/jpeg', 'image/png', 'application/pdf', 'application/msword', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document'];
         if (!allowedTypes.includes(file.type)) {
             return { success: false, error: "Tipe file tidak diizinkan." };
         }

        fileUrl = await saveFile(file);
        if (fileUrl === null) {
             return { success: false, error: "Gagal menyimpan file lampiran." };
        }
    }

    // Create a new submission document
    const newSubmission = new SubmissionModel({
      ...validatedData,
      name: validatedData.name || 'Anonymous', // Default to Anonymous if empty
      status: 'Pending', // Default status
      createdAt: new Date(),
      fileUrl: fileUrl, // Store the URL
      priority: 'Regular', // Default priority
       // referenceId will be generated by the Mongoose pre-save hook
    });

    // Save the submission to the database
    await newSubmission.save();

    console.log("New submission created (MongoDB):");

    // Return success and the generated referenceId
    return { success: true, referenceId: newSubmission.referenceId };

  } catch (error: any) {
    console.error("Error creating submission (MongoDB):", error);
    // Check for duplicate key error for referenceId
     if (error.code === 11000) {
         return { success: false, error: "Gagal membuat laporan: Terjadi duplikasi ID referensi. Coba lagi." };
     }
    return { success: false, error: error.message || "Gagal membuat laporan." };
  }
}

/**
 * Fetches submissions with filtering, sorting, searching, and pagination from MongoDB.
 * Ensures data is returned as plain objects.
 */
export async function fetchSubmissions(params: {
  category?: string;
  status?: string;
  sortBy?: string;
  search?: string;
  page?: number;
  limit?: number;
  isPublicView?: boolean; // Flag to potentially filter sensitive data for public view
}): Promise<{ submissions: Submission[]; totalCount: number; totalPages: number; }> {
  await dbConnect(); // Connect to the database

  try {
    const { category, status, sortBy = 'createdAt_desc', search, page = 1, limit = 10, isPublicView = true } = params;

    // Build the query object
    const query: any = {};
    if (category && category !== 'all') {
      query.category = category;
    }
    // Use lowercase status for querying the enum in the model
    if (status && status !== 'all') {
      query.status = status.toLowerCase();
    }

    // Add search functionality (case-insensitive regex search on description, category, referenceId, name)
    if (search) {
      const searchTerm = new RegExp(search, 'i'); // Case-insensitive regex
      query.$or = [
        { description: searchTerm },
        { category: searchTerm }, // Searching by category string
        { referenceId: searchTerm },
        { name: searchTerm }, // Include name in search
        // Consider including contactInfo if appropriate for public view
        // { contactInfo: searchTerm },
      ];
    }

    // Build the sort object
    let sort: any = {};
    switch (sortBy) {
      case 'date_asc':
        sort.createdAt = 1; // Ascending
        break;
      case 'date_desc':
      default:
        sort.createdAt = -1; // Descending
        break;
      case 'priority_asc':
         // Assuming priority is stored as 'Regular' (0) and 'Urgent' (1) or similar numeric/orderable value in DB
         // If stored as strings 'Regular' and 'Urgent', sort order might be alphabetical
         // Make sure priority field exists and is indexed if sorting often
         sort.priority = 1;
        break;
      case 'priority_desc':
          sort.priority = -1;
         break;
    }

    // Calculate pagination skip and limit
    const skip = (page - 1) * limit;

    // Fetch submissions and total count concurrently
    const [submissionsResult, totalCount] = await Promise.all([
      SubmissionModel.find(query)
        .sort(sort)
        .skip(skip)
        .limit(limit)
        .lean(), // Await the lean result
      SubmissionModel.countDocuments(query),
    ]);

    // Explicitly cast the awaited result to SubmissionDocument[]
    const submissions: SubmissionDocument[] = submissionsResult as SubmissionDocument[];

    const totalPages = Math.ceil(totalCount / limit);

    // Manually map Mongoose lean results to ensure plain objects and correct types
    const formattedSubmissions: Submission[] = submissions.map((sub: SubmissionDocument) => { // Explicitly type parameter
        const plainSub: Submission = {
            // Access properties directly after casting and typing
            id: sub._id.toString(), // Convert MongoDB _id to string
            referenceId: sub.referenceId,
            name: sub.name,
            // Conditionally hide contact info for public view
            contactInfo: (isPublicView && sub.name === 'Anonymous') ? undefined : sub.contactInfo, // Hide if Anonymous and public view
            category: sub.category,
            description: sub.description,
            // Ensure status and priority match the string literal types
            status: sub.status === 'pending' ? 'Pending' : sub.status === 'in progress' ? 'In Progress' : 'Resolved', // Map lowercase DB status to Capitalized frontend status
            createdAt: sub.createdAt.toISOString(), // Convert Date to ISO string
            fileUrl: sub.fileUrl || null, // Ensure null if missing
            priority: sub.priority as 'Urgent' | 'Regular', // Cast based on schema enum
        };

        // Handle internal comments if they exist and format their dates
        if (sub.internalComments && Array.isArray(sub.internalComments)) {
             // Comment type is already defined in SubmissionDocument and matches InternalComment closely
            plainSub.internalComments = sub.internalComments.map(comment => ({
                text: comment.text,
                author: comment.author,
                createdAt: comment.createdAt.toISOString(), // Ensure date is string (it's a Date object from Mongoose)
            }));
        }

        return plainSub;
    });

    return {
      submissions: formattedSubmissions,
      totalCount,
      totalPages,
    };

  } catch (error: any) {
    console.error("Error fetching submissions (MongoDB):", error);
    return { submissions: [], totalCount: 0, totalPages: 0 };
  }
}

/**
 * Gets a single submission by its reference ID from MongoDB.
 * Ensures data is returned as a plain object.
 */
export async function getSubmissionByReferenceId(referenceId: string): Promise<{ success: boolean; submission?: Submission; error?: string }> {
    await dbConnect(); // Connect to the database

    try {
        if (!referenceId || typeof referenceId !== 'string') {
             return { success: false, error: "ID Referensi tidak valid." };
        }

        // Find the submission by referenceId using .lean() and cast the result
        const submissionResult = await SubmissionModel.findOne({ referenceId }).lean();
        const submission: SubmissionDocument | null = submissionResult as SubmissionDocument | null; // Explicitly type after awaiting

        if (submission) {
             // Manually map Mongoose lean result to ensure a plain object
             const formattedSubmission: Submission = {
                // Access properties directly after casting and typing
                id: submission._id.toString(), // Convert MongoDB _id to string
                referenceId: submission.referenceId,
                name: submission.name,
                contactInfo: submission.contactInfo, // Decide if this should be hidden for public view
                category: submission.category,
                description: submission.description,
                status: submission.status === 'pending' ? 'Pending' : submission.status === 'in progress' ? 'In Progress' : 'Resolved', // Map lowercase DB status to Capitalized frontend status
                createdAt: submission.createdAt.toISOString(), // Convert Date to ISO string
                fileUrl: submission.fileUrl || null, // Ensure null if missing
                priority: submission.priority as 'Urgent' | 'Regular', // Cast
            };

            // Handle internal comments if they exist and format their dates
            if (submission.internalComments && Array.isArray(submission.internalComments)) {
                 // Comment type is already defined in SubmissionDocument and matches InternalComment closely
                formattedSubmission.internalComments = submission.internalComments.map(comment => ({
                    text: comment.text,
                    author: comment.author,
                    createdAt: comment.createdAt.toISOString(), // Ensure date is string
                }));
            }

            return { success: true, submission: formattedSubmission };
        } else {
            return { success: false, error: "Laporan tidak ditemukan." };
        }
    } catch (error: any) {
        console.error("Error fetching submission by ID (MongoDB):", error);
         if (error instanceof mongoose.Error.CastError) {
             return { success: false, error: "Format ID Submission tidak valid." };
         }
        return { success: false, error: "Gagal mengambil data laporan." };
    }
}


// --- Admin Actions (Placeholder - Requires Authentication/Authorization) ---

/**
 * Updates the status or priority of a submission (Admin only).
 * Updates data in MongoDB.
 */
export async function updateSubmissionStatus(id: string, status: string, priority?: string): Promise<{ success: boolean; error?: string }> {
    // !!! IMPORTANT: Add authentication and authorization checks here !!!
    // Ensure only authorized admins can perform this action.
    await dbConnect(); // Connect to the database

    try {
        // Validate status against allowed enum values (case-insensitive check for input, use lowercase for DB)
        const allowedStatuses = ['Pending', 'In Progress', 'Resolved'];
        const statusLower = status.toLowerCase();
        if (!allowedStatuses.map(s => s.toLowerCase()).includes(statusLower)) {
             return { success: false, error: "Status tidak valid." };
        }

        const updateDoc: any = { status: statusLower };

         // Validate priority if provided
        if (priority) {
             const allowedPriorities = ['Urgent', 'Regular'];
             // Assuming priority is stored exactly as 'Urgent' or 'Regular' in DB enum
             if (!allowedPriorities.includes(priority)) {
                 return { success: false, error: "Prioritas tidak valid." };
             }
             updateDoc.priority = priority; // Use provided case for priority enum
        }

        // Find and update the submission by its MongoDB _id
        // Use findByIdAndUpdate and .lean() to get the updated plain object
        const result = await SubmissionModel.findByIdAndUpdate(id, updateDoc, { new: true }).lean() as SubmissionDocument | null; // Cast result after awaiting

        if (!result) {
            return { success: false, error: "Submission not found." };
        }

        console.log("Submission updated (MongoDB):");

        // TODO: Send notification to user if contact info exists and status changed

        return { success: true };
    } catch (error: any) {
        console.error("Error updating submission status (MongoDB):", error);
        // Check if the ID is a valid MongoDB ObjectId format
         if (error instanceof mongoose.Error.CastError) {
             return { success: false, error: "Format ID Submission tidak valid." };
         }
        return { success: false, error: "Failed to update submission." };
    }
}

/**
 * Adds an internal comment to a submission (Admin only).
 * Updates data in MongoDB.
 */
export async function addInternalComment(id: string, comment: string, adminName: string): Promise<{ success: boolean; error?: string }> {
    // !!! IMPORTANT: Add authentication and authorization checks here !!!
     await dbConnect(); // Connect to the database

    try {
        // Find the submission by its MongoDB _id and push a new comment
        // Use findByIdAndUpdate with $push and .lean() to get the updated plain object
        const result = await SubmissionModel.findByIdAndUpdate(
            id,
            { $push: { internalComments: { text: comment, author: adminName, createdAt: new Date() } } },
            { new: true } // Return the updated document
        ).lean() as SubmissionDocument | null; // Cast result after awaiting

         if (!result) {
            return { success: false, error: "Submission not found." };
        }

         console.log("Internal comment added (MongoDB):");

        return { success: true };
    } catch (error: any) {
        console.error("Error adding internal comment (MongoDB):", error);
         if (error instanceof mongoose.Error.CastError) {
             return { success: false, error: "Format ID Submission tidak valid." };
         }
        return { success: false, error: "Failed to add comment." };
    }
}

/**
 * Fetches submission statistics (Admin only).
 * Reads data from MongoDB.
 * Ensures data is returned as a plain object.
 */
export async function getSubmissionStats(): Promise<{ success: boolean; stats?: any; error?: string }> {
    // !!! IMPORTANT: Add authentication and authorization checks here !!!
     await dbConnect(); // Connect to the database

    try {
        // Get total count
        const totalSubmissions = await SubmissionModel.countDocuments({});

        // Aggregate counts by category
        const categoryCountsArray = await SubmissionModel.aggregate([
            { $group: { _id: '$category', count: { $sum: 1 } } },
            { $project: { _id: 0, category: '$_id', count: 1 } }
        ]);
        const categoryCounts = categoryCountsArray.reduce((acc, item) => {
            acc[item.category] = item.count;
            return acc;
        }, {} as Record<string, number>);

        // Aggregate counts by status
         const statusCountsArray = await SubmissionModel.aggregate([
            { $group: { _id: '$status', count: { $sum: 1 } } },
            { $project: { _id: 0, status: '$_id', count: 1 } }
        ]);
        // Convert status keys back to Capitalized for consistency if needed
         const statusCounts = statusCountsArray.reduce((acc, item) => {
             // Simple capitalization logic (adjust if needed based on actual enum values)
             const capitalizedStatus = item._id.charAt(0).toUpperCase() + item._id.slice(1);
             acc[capitalizedStatus] = item.count;
            return acc;
        }, {} as Record<string, number>);

        const stats = {
            totalSubmissions,
            categoryCounts,
            statusCounts,
            // Add more stats aggregation as needed
        };

        // Ensure stats object is plain
        return { success: true, stats: JSON.parse(JSON.stringify(stats)) };

    } catch (error: any) {
        console.error("Error fetching stats (MongoDB):", error);
        return { success: false, error: "Failed to fetch statistics." };
    }
}
